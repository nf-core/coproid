---
title: "coproID report test"
format: 
    nf-core-html: default
editor: visual
---


```{r echo = FALSE, message = FALSE, warning = FALSE}
library(ggplot2)
library(plotly)
library(tibble)
library(rlang)
library(magrittr)
library(tidyr)
library(plotly)
library(knitr)
library(ggh4x)
```

_Pipeline version 2.0_

# Introduction

[coproID](https://github.com/nf-core/coproID) is a pipeline designed to identify the source of coprolites, but can also be used to track the source of other metagenomic samples. More information regarding the pipeline and the output files can be found here: [coproid.readthedocs](https://coproid.readthedocs.io/en/latest/output.html)

# Host DNA

**Figure 1.** **Stacked barplot of source prediction per sample based on the mapping and [sam2lca](https://sam2lca.readthedocs.io/en/latest/) results.**

```{r echo = FALSE, message = FALSE, warning = FALSE}

sam2lca <- read.csv("coproid.sam2lca_merged_report.csv")
colnames(sam2lca) <- gsub("name", "Name", colnames(sam2lca))
genomes <- read.csv("genomesheet.csv")
colnames(genomes) <- gsub("taxid", "TAXID", colnames(genomes))

sam2lca <- merge(sam2lca, genomes[, c("TAXID", "genome_size")], 
                 by = "TAXID", all.x = TRUE)
sam2lca <- sam2lca[, c(setdiff(colnames(sam2lca), "genome_size")[1:3],
            "genome_size", setdiff(colnames(sam2lca), "genome_size")[-(1:3)])]


sample_columns <- colnames(sam2lca)[5:ncol(sam2lca)]

num_rows <- nrow(sam2lca)

sam2lca$normalisation_factor <- (sum(sam2lca$genome_size) / num_rows) / sam2lca$genome_size

sam2lca <- sam2lca[, c(setdiff(colnames(sam2lca), "normalisation_factor")[1:4],
            "normalisation_factor", setdiff(colnames(sam2lca),
            "normalisation_factor")[-(1:4)])]

# Normalize the sample columns by multiplying with the normalization factor
for (col in sample_columns) {
  sam2lca[[paste0(col, "_normalised")]] <- sam2lca[[col]] * sam2lca$normalisation_factor
}

table <- sam2lca

if (ncol(as.data.frame(sam2lca[, -c(1:3)])) > 1) {
  sam2lca[, -c(1:3)] <- sweep(sam2lca[, -c(1:3)], 2, colSums(sam2lca[, -c(1:3)]), FUN = "/")
} else {
  sam2lca[, 4] <- sam2lca[, 4] / sum(sam2lca[, 4])
}

sam_long <- sam2lca %>%
  pivot_longer(cols = contains("_normalised"),
               names_to = "Sample",
                values_to = "Fraction")

sam_plot <- ggplot(sam_long, aes(x = Fraction,
                  y = Sample, fill = Name, text = paste("Sample:", Sample))) +
  geom_bar(stat = "identity") +
  scale_fill_brewer(palette = "Set2")

ggplotly(sam_plot, tooltip = "all") 
```
<p style="margin-bottom: 0.75cm;"></p>

**Table 1. Raw and normalised number of reads per sample based on the mapping and sam2lca results.**
```{r echo = FALSE, message = FALSE, warning = FALSE}

table <- table %>%
  mutate(
    normalisation_factor = sprintf("%.2f", normalisation_factor), 
    across(where(is.numeric) & !matches("normalisation_factor"), ~ round(., 0)) 
  )

# Create the kable table
kable(table)

```

# Microbial source tracking

**Figure 2.** **Stacked barplot of source prediction per sample based on the [sourcepredict](https://sourcepredict.readthedocs.io/en/latest/usage.html) analysis.**

```{r echo = FALSE, message = FALSE, warning = FALSE}

sp <- read.csv("coproid.report.sourcepredict.csv") 
sp$X <- gsub("unknown", "Unknown", sp$X)
sp$X <- gsub("_", " ", sp$X)
spT <- t(sp[-1]) %>%
  as.data.frame()
colnames(spT) <- sp$X
spT <- rownames_to_column(spT, var = "Sample")

sp_long <- spT %>%
  pivot_longer(
    cols = c(,-1),
    names_to = "Taxa",
    values_to = "Fraction")

portions <- ggplot(sp_long, aes(x = Fraction, y = Sample, fill = Taxa)) +
  geom_col() +
  scale_fill_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(hjust = 1, size = 8))
  
interactive_plot <- ggplotly(portions, tooltip = "all")
interactive_plot
```

<p style="margin-bottom: 0.75cm;"></p>

**Table 2. Source prediction per sample based on the [sourcepredict](https://sourcepredict.readthedocs.io/en/latest/usage.html) analysis.**

```{r echo = FALSE, message = FALSE, warning = FALSE}

kable(spT)
```

# Embedding

**Figure 3. Scatter plot based on the embedding file generated by [sourcepredict](https://sourcepredict.readthedocs.io/en/latest/usage.html).**

```{r echo = FALSE, message = FALSE, warning = FALSE}

embedding <- read.csv(file = 'coproid.embedding.sourcepredict.csv')
colnames(embedding) <- gsub("labels", "Labels", colnames(embedding))
embedding$Labels <- gsub("_", " ", embedding$Labels)
embedding$Labels <- gsub("known", "Unknown", embedding$Labels)

scatter <- ggplot(data = embedding, 
       mapping = aes(x = PC2, y = PC1 , 
                     color = Labels,  
       text = paste("Name:", name))) + 
  geom_point() + theme_classic() +
  scale_colour_brewer(palette = "Set2") 

interactive_plot <- ggplotly(scatter, tooltip = "all")
interactive_plot

```

# Ancient DNA damage

**Figure 4. Pydamage results**

```{r echo = FALSE, message = FALSE, warning = FALSE}

pydamage <- read.csv("coproid.pydamage_merged_report.csv")
pydamage$Taxa <- gsub("_", " ", pydamage$Taxa)
pydamage$log <- -log10(pydamage$pvalue)

ggplot(pydamage, aes(x = damage_model_pmax, y = log, 
                      colour = Sample, shape = Taxa)) +
                  geom_point(size = 3) +
                  labs(x = "Modelled amount of damage on 5' end", 
                       y = "-log(10)(p-value)",
                       title = "") +
                  guides(colour = guide_legend(title = "Sample"),
                         shape = guide_legend(title = "Taxa"))

#ggplotly(pydamage_plot, tooltip = "all") 
```

# Damage profiler

**Figure 5. Individual damage plots with 5' end (left) and 3' end (right)**

```{r echo = FALSE, message = FALSE, warning = FALSE}

damage <- read.csv("coproid.damageprofiler_merged_report.csv", header = TRUE, sep = "")
colnames(damage) <- gsub("X", "", colnames(damage))
damage$Reference <- gsub("_", " ", damage$Reference)

damage_long <- damage %>%
  gather(key = "position", value = "value", 
         -c(1:3)) %>%
  mutate(position = as.numeric(position))

damage_long <- damage_long %>%
  mutate(prime_end = factor(prime_end, levels = c("5pCtoT", "3pGtoA")))

# Create the plot for each sample with 5pCtoT on the left and 3pGtoA on the right
damage_plot <- ggplot(damage_long, aes(x = position, y = value, 
                    color = Reference, group = Reference)) +
  geom_line() +
  facet_grid(Sample ~ prime_end, scales = "free_x") +
  theme_minimal() +
  scale_colour_brewer(palette = "Set2") +
  labs(x = "Distance (bp)", y = "Deamination frequency") +
  theme(panel.spacing = unit(1, "lines")) +
  theme(strip.text.y = element_text(angle = 0, size = 8))

# Set scales for each subplot
position_scales <- list(
  scale_x_continuous(), scale_x_reverse())

damage_plot <- damage_plot + facetted_pos_scales(x = position_scales)
# Final plot
damage_plot

```
